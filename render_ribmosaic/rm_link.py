# #############################################################################
# AUTHOR BLOCK:
# #############################################################################
#
# RIB Mosaic RenderMan(R) IDE, see <http://sourceforge.net/projects/ribmosaic>
# by Eric Nathen Back aka WHiTeRaBBiT, 01-24-2010
# This script is protected by the GPL: Gnu Public License
# GPL - http://www.gnu.org/copyleft/gpl.html
#
# #############################################################################
# GPL LICENSE BLOCK:
# #############################################################################
#
# Script Copyright (C) Eric Nathen Back
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# #############################################################################
# COPYRIGHT BLOCK:
# #############################################################################
#
# The RenderMan(R) Interface Procedures and Protocol are:
# Copyright 1988, 1989, 2000, 2005 Pixar
# All Rights Reserved
# RenderMan(R) is a registered trademark of Pixar
#
# #############################################################################
# COMMENT BLOCK:
# #############################################################################
#
# Pipeline link module responsible for creating and resolving link tokens.
#
# This script is PEP 8 compliant
#
# Search TODO for incomplete code
# Search FIXME for improper code
# Search XXX for broken code
#
# #############################################################################
# END BLOCKS
# #############################################################################

import os,re
import sys
import bpy


# #### Global variables

MODULE = os.path.dirname(__file__).split(os.sep)[-1]
exec("from " + MODULE + " import rm_error")
exec("from " + MODULE + " import rm_context")
exec("import " + MODULE + " as rm")


# #############################################################################
# PIPELINE LINK CLASS
# #############################################################################

# #### Object representing and resolving XML Pipeline links

class PipelineLink(rm_context.ExportContext):
    """
    Object containing pipeline link and methods necessary to resolve the data
    pointed to by the link.

    Links insert text from one XML element into the text or attribute of
    another element. Link format is @[token:xmlpath(paras):option*depth]@
    where token determines the link type, xmlpath points to the data, paras
    can be named parameters, option filters the returned string and depth sets
    the max recursion depth. Named parameters only work for EXEC tokens and
    can themselves contain links. Links can also be nested in one another and
    are evaluated inside out.

    Here's details of link format

    Token Types:
    EVAL = Python expression or "." + export context variable
    EXEC = XML path to script or "." + export context method
           (both use parameters)
    STXT = Text editor shaders export path in OS or RIB format
           depending on options
    SXML = XML shaders export path in OS or RIB format depending on options
    SLIB = Library shaders path in OS or RIB format depending on options
    TEXT = Text element link (returns elements text)
    ATTR = Attribute element link (returns elements attribute)
    PATH = Return full XML path from relative path (handy for scripts)
    DATA = Return property data from either xmlpath or "." + datapath
    PROP = Return property name generated by RIB Mosaic from xmlpath

    Path Syntax:
    XML absolute = root_element/sub_element/sub_element
    XML relative = //sub_element
    ATTR = root_element/sub_element/.../sub_element.attribute

    Options:
    #### = Returns numbers with leading zeros up to number of # characters
    RIB = Returns in RIB format (for paths returns nix relative export path)
    RSL = Returns in RSL format
    PY = Returns in Python format
    STR = Returns as a quoted string
    unspecified = Data is converted to string
    *# = Sets the recursion limit for current link
    """
    
    # #### Public attributes

    pipeline_link = ""  # pipeline link this object represents
    recursion_max = 100  # Maximum level of link recursion

    # #### Private attributes

    _link_list = []  # Collect link chains to determine recursion level

    # 'token type':"xml category element"
    _link_tokens = {'EVAL': "evals",
                   'EXEC': "python_scripts",
                   'SXML': "shader_sources",
                   'SLIB': "shader_sources",
                   'STXT': "shader_sources",
                   'TEXT': "texts",
                   'ATTR': "",
                   'PATH': "",
                   'DATA': "",
                   'PROP': ""}

    # #### Private methods

    def __init__(self, export_object, pipeline_link=""):
        """Initialize attributes using export_object and pipeline_link.

        export_object = Any object subclassed from ExportContext
        pipeline_link = The link this object represents and resolves to text
        """

        rm_context.ExportContext.__init__(self, export_object)

        self.pipeline_link = pipeline_link

        if export_object:
            self._link_tokens['DATA'] = self.context_category
            self.recursion_max = getattr(export_object,
                                         "recursion_max",
                                         self.recursion_max)

    def _resolve_path(self):
        """Resolve data from destination of this object's link"""

        def flatten_list(data, app=None):
            """Convert input data into one single list"""
            if app is None:
                app = []
            if not isinstance(data,str):
                    try:
                        for e in data:
                            flatten_list(e,app)
                    except:
                        app.append(data)
            else:
                app.append(data)
            return app
            
        def convert_to_string(l,bracketS="[",bracketE="]", delim=" "): 
            """ convert each type in the list l to a total string delimited
            string types are additionaly quoted by spaces and inclosed 
            in brackets"""
            for i,v in enumerate(l):
                
                if isinstance(v,float):
                    # convert float to precision format
                    # don't quote numbers
                    l[i] = "%.9f" % v
                elif isinstance(v,int):
                    l[i] = "%i" % v
                elif isinstance(v,bool):
                    # no bools in rib , just 1 or 0
                    if v:
                        l[i] = "1"
                    else:
                        l[i] = "0"
                else: # all other types convert to string and quote
                    # quote rib strings
                    l[i] = '"'+ str(v) + '"'

            # join all strings together and inclose between brackets [ ]
            return bracketS + delim.join(l) + bracketE;
            
        #print("Resolve path:", self.pipeline_link)
        
        if "@[" in self.pipeline_link:
            link = self.pipeline_link.replace("@[", "").replace("]@", "")
        else:
            link = self.pipeline_link

        # Separate EXEC token parameters
        if link.startswith('EXEC') and "(" in link:
            llink = link.split("(", 1)
            rlink = llink[1].rsplit(")", 1)
            link = llink[0] + rlink[1]
            paras = rlink[0]
        else:
            paras = ""

        # Split out segments
        text = ""
        try:
            token = link.split(":", 1)[0]
        except:
            token = ""

        try:
            path = link.split(":", 1)[1].rsplit(":", 1)[0]
        except:
            path = ""

        try:
            option = link.rsplit(":", 1)[1].split("*")[0]
        except:
            option = ""

        try:
            self.recursion_max = int(link.rsplit(":", 1)[1].split("*")[1])
        except:
            pass

        if token not in self._link_tokens:
            rm.RibmosaicInfo("Available token types: " +
                             ", ".join(self._link_tokens))
            raise rm_error.RibmosaicError("Invalid token type \"" + token +
                                          "\" in link @[" + link + "]@")

        # Resolve any relative links and set absolute paths
        if token != 'EVAL':  # Make sure this has a xmlpath
            # Strip path according to token type
            if token == 'EXEC':
                segs = path.split("(", 1)
            elif token == 'ATTR':
                segs = path.split(".", 1)
            else:
                segs = [path]

             # Ignore EXEC commands
            if not path.startswith(".") or token == 'ATTR':
                elements = segs[0].split("/")

                # Guess category by token type otherwise use current category
                if self._link_tokens[token]:
                    category = self._link_tokens[token]
                else:
                    category = self.context_category

                current_path = [self.context_pipeline,
                                category,
                                self.context_panel,
                                "properties"]

                for i, e in enumerate(elements[:4]):
                    if not e:  # resolve relative path
                        elements[i] = current_path[i]
                    elif e != current_path[i]:  # Set absolute path
                        if i == 0:
                            self.context_pipeline = e
                        elif i == 1:
                            self.context_category = e
                        elif i == 2:
                            self.context_panel = e

                segs[0] = "/".join(elements)

            # Recombine path according to token type
            if token == 'EXEC':
                path = "(".join(segs)
            elif token == 'ATTR':
                path = ".".join(segs)
            else:
                path = segs[0]

        # Return link information depending on type
        try:
            if token == 'STXT' or token == 'SXML':
                if token == 'STXT':
                    path = "Text_Editor"

                export = rm.export_manager.export_directory
                paths = rm.export_manager.export_paths
                text = export + os.sep.join(paths['SHD']) + os.sep + \
                       path + os.sep
            elif token == 'SLIB':
                lib = rm.pipeline_manager.get_attr(self, path, "library")

                if lib:
                    text = os.path.realpath(bpy.path.abspath(lib)) + os.sep
                else:
                    rm.RibmosaicInfo("SLIB requires a pipeline library path")
                    text = ""
            elif token == 'DATA' or token == 'PROP':
                if path.startswith(".") or "properties" in path:
                    if "properties" in path:
                        segs = path.split("/")
                        link = rm.pipeline_manager.get_attr(self, path,
                                                            "link", False)

                        # Do we get property from link or pipeline property?
                        if link:
                            prop = link
                        else:
                            prop = rm.PropertyHash("".join(segs[:3]) + segs[4])
                    else:
                        prop = path[1:]

                    if token == 'DATA':
                        if self.pointer_datablock:
                            try:
                                text = eval("self.pointer_datablock." + prop)
                            except:
                                rm.RibmosaicInfo("Property \"" + prop + \
                                        "\" does not exist on this datablock")
                                text = ""
                        else:
                            rm.RibmosaicInfo("No datablock specified"
                                " in ExportContext")
                            text = ""
                    else:
                        text = prop
                else:
                    rm.RibmosaicInfo("DATA and PROP links only work for"
                        " panel properties")
                    text = ""
            elif token == 'ATTR':

                if "." in path:
                    segs = path.split(".")
                    text = rm.pipeline_manager.get_attr(self, segs[0], segs[1])
                else:
                    text = ""
            elif token == 'PATH':
                text = path
            elif token == 'EVAL':
                if path.startswith("."):
                    text = eval("self" + path)
                else:
                    text = eval(path)
            elif token == 'EXEC':
                try:
                    if path.startswith("."):  # Is this is an exporter method
                        exec("self" + path + "(" + paras + ")")
                    else:  # Is this a exec script
                        local = locals()
                        local['output'] = ""

                        def paras2dict(dictionary, **paras):
                            """
                            Add parameters to dictionary to pass through exec
                            """

                            for p in paras:
                                dictionary[p] = paras[p]

                        # Pass function parameters to local dictionary
                        exec("paras2dict(local, " + paras + ")")
                        # Execute function passing local dictionary
                        exec(rm.pipeline_manager.get_text(self, path),
                             globals(), local)

                        # Pass any function output through link text
                        text = local['output']
                except:
                    raise rm_error.RibmosaicError("Error in script exec:\n" +
                                text, sys.exc_info())
            else:
                text = rm.pipeline_manager.get_text(self, path)
        except:
            raise rm_error.RibmosaicError("Error in link @[" + link + "]@",
                                          sys.exc_info())

        # If link result is text and has links resolve them
        if isinstance(text,str) and "@[" in text:
            text = self._resolve_links(text)

        # Filter output text according to token option
        if option:
            if '#' in option:  # Return leading zeros
                text = str(text)

                if text.isdigit():
                    text = str(int(float(text)))
                    text = option.replace("#", "0")[len(text):len(option)] + \
                           text
                else:
                    rm.RibmosaicInfo("Link must return numbers to"
                                     " use # option")
                                     
            elif option == 'RIB':  # Parse text for RIB output
                
                if token == 'STXT' or token == 'SXML' or token == 'SLIB' or \
                  (token == 'EVAL' and path.startswith(".") and \
                  "path" in path):
                    export = rm.export_manager.export_directory
                    text = rm.RibPath(os.path.relpath(text, export)) + "/"
                else:
                    # text might be a list [ "asd", ["asd","3"]] -> output '[ "asd" "asd" "3"]'
                    # unfold into one list, containing all non-iterable types
                    # and combine all types in the array to a total RIB string
                    text = convert_to_string(flatten_list(text),"[","]")
                    
            elif option == 'RSL':  # Parse text for RSL output
                text = convert_to_string(flatten_list(text),"{","}")
                
            elif option == 'PY':  # Parse text for Python output
                text = repr(text)
            else:  # Parse text as string (do not resolve links)
                text = "\"" + str(text) + "\""

        else:
            text = str(text)
            
        #print("Resolved: " , text, type(text))
        return text

    # #### Public methods

    def resolve_link(self):
        """
        Resolve link data processing according to link type and return result
        """

        self._link_list.append(self.pipeline_link)

        # Make sure we are not caught in a recursive loop
        if self._link_list.count(self.pipeline_link) <= self.recursion_max:
            text = self._resolve_path()
        else:
            text = ""

        self._link_list.pop()

        return text
